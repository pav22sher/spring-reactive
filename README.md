### Проблема

Контейнер сервлетов(Например, Tomcat) имеет выделенный пул потоков 
для обработки HTTP-запросов, где каждому входящему запросу будет назначен поток,
и этот поток будет обрабатывать весь жизненный цикл запроса (модель «поток на запрос»). 
Это означает, что приложение сможет обрабатывать количество одновременных запросов, 
равное размеру пула потоков. Можно настроить размер пула потоков, 
но поскольку каждый поток резервирует некоторую память (обычно 1 МБ), 
чем больший размер пула потоков мы настраиваем, тем выше потребление памяти.
Таким образом, модель потока на запрос может стать довольно дорогостоящей 
для приложений с большим количеством одновременных запросов.

Такой же тип потерь также возникает при ожидании завершения других типов операций 
ввода-вывода, таких как вызов базы данных или чтение из файла. 
Во всех этих ситуациях поток, выполняющий запрос ввода-вывода, 
будет заблокирован и будет ожидать, пока операция ввода-вывода не будет завершена, 
это называется блокирующим вводом-выводом. 
Такие ситуации, когда выполняющийся поток блокируется, просто ожидая ответа, 
означают потерю потоков и, следовательно, потерю памяти.

#### Преимущества реактивного программирования заключаются:
* отходим от модели поток на запрос и можем обрабатывать больше запросов с небольшим количеством потоков
* предотвращаем блокировку потоков при ожидании завершения операций ввода-вывода
* упрощаем параллельные вызовы
* поддерживаем «обратное давление», давая клиенту возможность сообщить серверу, с какой нагрузкой он может справиться

### Реактивное программирование

Реактивное программирование - это неблокирующие приложения, которые являются асинхронными 
и управляемыми событиями и требуют небольшого количества потоков для масштабирования. 
Ключевым аспектом этого определения является концепция противодавления (backpressure), 
которая является механизмом, гарантирующим, что производители не перегружают потребителей

### Reactive Streams

Реактивные потоки - это небольшая спецификация, предназначенная для реализации реактивными библиотеками,
созданными для JVM. Он определяет типы, которые необходимо реализовать для достижения взаимодействия 
между различными реализациями. Спецификация определяет взаимодействие между асинхронными компонентами 
с противодавлением.

#### Спецификация Reactive Streams включает следующие интерфейсы:
* Publisher - производитель данных
```java
public interface Publisher<T> {
    //подписка на издателя
    void subscribe(Subscriber<? super T> s);
}
```
* Subscriber - потребитель данных
```java
public interface Subscriber<T> {
    //перед началом обработки
    void onSubscribe(Subscription s);
    //сигнал о новом элементе
    void onNext(T t);
    //сигнал об ошибке
    void onError(Throwable t);
    //сигнал о том, что все элементы успешно отправлены
    void onComplete();
}
```
* Subscription - позволяет клиенту управлять выдачей элементов
```java
public interface Subscription {
    //сколько дополнительных элементов будет опубликовано
    void request(long n);
    //позволяет подписчику отменить дальнейшую отправку элементов
    void cancel();
}
```
* Processor - преобразовывать входящие элементы, а затем передавать их другому Subscriber
```java
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```

### FLUX и MONO
* Mono - это Publisher, который может испускать от 0 до 1 элемента
* Flux - это Publisher, который может испускать от 0 до N элементов

### R2DBC
R2DBC - Reactive Relational Database Connectivity - реактивного неблокирующего API для работы с БД.